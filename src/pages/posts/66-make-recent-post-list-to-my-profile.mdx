import PostUtil from "../../utils/postUtil";
import PostLayout from "../../components/post/PostLayout"; import WavyLine from "../../components/WavyLine"; import Aside
    from "../../components/mdx/Aside";

### 이 포스트에서 다루는 내용

- GitHub webhook - `repository_dispatch`: 다른 레포지토리의 액션 워크플로우 트리거시키기
- act: 로컬에서 깃허브 액션 워크플로우 실행하기
- git clone으로 받아온 파일의 생성시점 가져오기

<WavyLine size={8} />

작년까지는 꽤 평범한(?) 깃허브 프로필을 사용하고 있었다.

![Untitled](/image/66/profile1.png)

그런데 이런 형식은 다른 사람들과 너무 비슷한 느낌인 것 같아서, 나를 좀 더 잘 드러내는 프로필을 쓰고 싶었다.

<br/>

어떤 식으로 프로필을 만들어야 나를 더 잘 드러낼 수 있을지 고민하던 끝에…

![Untitled](/image/66/profile2.png)

결국 인삿말만 남기고 나머지는 삭제했다. 😓

<br/>

그러다가 [How to Create a Dynamic Github Profile](https://asterhu.com/post/2021-10-01-build-readme-automatically/) 이라는 포스팅을 읽게 됐다. 요약하자면 github action에 스케줄을 설정해, 매일 자정마다 자신의 블로그의 최신 포스트를 긁어와 README 파일에 최신 포스팅을 작성하는 내용이다.

나를 가장 잘 드러낼 수 있는 건 블로그 포스팅이라고 할 수 있고, 최근에 글또 활동을 하면서 글을 많이 쓰고 있기도 해서 깃허브 프로필에 최신 블로그 포스팅 목록을 보여주면 좋을 것 같았다. 그리고 블로그를 직접 개발해 깃허브 레포지토리에 올려 두고 있기 때문에, 깃허브 액션을 사용해 푸시가 발생할 때마다 프로필 레포지토리를 수정해 주면 될 것 같았다.

<br/>

그래서 깃허브 액션을 적용한 지금, [이런 프로필](https://www.github.com/ooooorobo)이 됐다. :)

![Untitled](/image/66/profile3.png)

## 구현 아이디어

가장 먼저 생각한 아이디어는 블로그 레포지토리에서 프로필 readme.md 파일을 만들어서 push 해주는 방법이었다.

![제목 없는 다이어그램-페이지-1.drawio.png](/image/66/diagram1.png)

블로그 레포지토리의 push 이벤트가 발생하면, `make-post-list-action`을 발생시켜 블로그에 작성된 최신 포스트 5개의 정보를 알아온다. 이 데이터를 적절히 가공해 프로필에서 보여줄 마크다운 형식으로 변환한다.

깃허브 프로필의 정적인 부분의 정보를 담고 있는 `profile-readme-template.md` 파일을 열어, 동적으로 변경해줄 부분에 최신 포스트 리스트를 넣어준다. 이 파일의 내용을 프로필 레포지토리에 있는 `readme.md` 파일에 덮어씌워서 프로필 레포지토리에 커밋 후 푸시한다.

<br/>

이 구조의 문제점은 블로그 레포지토리에서 최신 포스트 데이터를 뽑아내는 것 뿐만 아니라 프로필을 어떻게 작성할 지에 대해서도 알고 있어야 한다는 것이다.

즉, 만약 내 프로필을 변경하고 싶다면, 프로필 레포지토리의 파일을 수정하는 게 아니라 블로그 레포지토리의 `profile-readme-template.md` 파일을 수정해줘야 한다. 프로필 레포지토리의 `readme.md` 파일은 블로그 레포지토리에 push가 일어나면 덮어씌워질 파일이기 때문이다.

이렇게 프로필 레포지토리에서 자신의 `README.md` 파일이 어떻게 변경될지 모르는 구조는 유지보수하기 어려워 적절하지 않다.

<br/>

물론 이런 구조도 가능하다! `profile-readme-template.md`를 프로필 레포지토리가 가지고 있고, 블로그 레포지토리는 그 템플릿을 가져다가 내용을 변경한 뒤, 프로필 레포지토리의 `readme.md`를 덮어쓰고 프로필 레포지토리에 커밋 후 푸시하는 방식이다.

![제목 없는 다이어그램-페이지-1.drawio (1).png](/image/66/diagram2.png)

이렇게 하면 프로필을 변경하기 위해 블로그 레포지토리의 파일을 변경해야 하는 문제는 해결할 수 있다.

그렇지만 애초에 블로그 레포지토리에서 프로필 레포지토리의 파일을 변경한다는 것 자체가 이상하다. 프로필 레포지토리는 언제 어떻게 변경이 일어날 지도 모르는 채 파일이 변경되는 것이다.

블로그 레포지토리도 여전히 프로필 레포지토리가 가지고 있는 파일에 대해 알아야 한다. `profile-readme-template.md`의 파일 내용 중에서 어느 부분에 최신 포스트 목록에 대해 작성해 줄 지 알아야 하기 때문이다.

<br/>

그래서, 두 레포지토리가 모두 액션을 가지고 있는 구조로 만들었다.

![제목 없는 다이어그램-페이지-2.drawio.png](/image/66/diagram3.png)

먼저, 블로그 레포지토리에 push 이벤트가 발생하면 `dispatch-post-list-action` 액션이 실행된다. 이 액션은 블로그 포스트 중 최신 5개 포스트의 정보를 가져오고, 이 데이터를 프로필 레포지토리에 dispatch 해주는 역할**만** 한다.

프로필 레포지토리는 `repository_dispatch` 이벤트 시점에 `update-profile` 액션을 실행시킨다. 이 액션에서는 dispatch를 통해 받은 최신 포스트 데이터를 잘 가공해서 `profile-readme-template.md` 파일의 특정 부분에 넣어준 다음, `readme.md` 파일을 덮어쓰고 커밋 후 푸시해서 깃허브 프로필을 변경할 것이다.

이렇게 하면, 블로그 레포지토리는 최신 포스트를 뽑아내는 일만, 프로필 레포지토리는 readme 파일을 가공하는 일만 하면 되고, 두 레포지토리는 서로를 몰라도 되는 구조가 된다.

# Repository Dispatch Event

다른 레포지토리의 깃허브 액션 워크플로우를 트리거시키기 위해서, `repository_dispatch` 웹훅을 사용한다. 이 웹훅에 대해서는 [공식 문서](https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#create-a-repository-dispatch-event)에서 확인할 수 있다.

이 웹훅을 사용하기 위해서는 웹훅을 받을 레포지토리의 Contents write 권한을 가진 Personal access token이 필요하다.

<Aside>
💡 **토큰 발급받는 방법**
1. 다음 경로로 진입: 프로필 > 설정 > Developer settings > Personal access tokens > Fine-grained tokens > Generate new token
2. 아래 내용과 같이 토큰 설정
    - Repository access > Only select repositories > repository_dispatch 이벤트를 **받길** 원하는 레포지토리만 선택
    - Permissions > Repository permissions > **Contents: Read and wirte** 권한 설정
3. 발급된 토큰은 복사해서 안전한 곳에 기록해둔다

</Aside>

`repository_dispatch` 웹훅을 테스트해보기 위해 간단한 [테스트 레포지토리](https://github.com/ooooorobo/dispatch-test)를 만들었다. 먼저, `repository_dispatch` 웹훅을 받으면 `client_payload`에 포함된 message를 출력하는 액션을 만들었다.

```yaml
on:
  repository_dispatch:
    types: [test_result] # event_type이 test_result인 이벤트를 받았을 때 액션이 트리거된다

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - env:
          MESSAGE: ${{ github.event.client_payload.message }}
        run: echo $MESSAGE
```

그런 다음, 아래와 같은 HTTP POST 요청을 보내 웹훅을 트리거한다.

```bash
curl -L \
  -X POST \
  -H 'Accept: application/vnd.github+json' \
  -H "Authorization: Bearer ${TOKEN}" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  https://api.github.com/repos/${owner}/${repo-name}/dispatches \
  -d '{"event_type": "test_result", "client_payload": {"message":"test"}}'
```

위에서 발급받은 토큰을 `${TOKEN}` 부분에 넣고, owner와 repo-name 부분에 레포지토리 소유자와 레포지토리 이름을 적어준다.

데이터로는 event_type에 트리거시킬 이벤트 타입 문자열을, client_payload에 전달할 JSON 데이터를 문자열로 변환해 넣어주면 된다.

<br/>

curl 커맨드를 실행하면, repository_dispatch 이벤트가 트리거되어 깃허브 액션이 실행된다. 전달한 데이터를 잘 출력하고 있다.

![Untitled](/image/66/dispatch-test-echo.png)

# 최근 포스트 가져오는 액션 만들기

우선, node로 파일을 가져오는 코드를 만들었다. 전체 코드는 [여기](https://github.com/ooooorobo/ooooorobo.github.io/blob/main/.github/make-post-list.js)에서 볼 수 있다.

이 자바스크립트 코드는 블로그 포스트가 있는 디렉토리의 파일을 모두 불러온 다음, 최근에 생성된 5개 파일의 메타 데이터를 뽑아내 반환하는 코드이다.

## 포스트 데이터를 가공해서 내보내기

뽑아낸 데이터를 액션 워크플로우로 내보내주기 위해 [`@actions/core`](https://github.com/actions/toolkit/tree/main/packages/core) 라이브러리를 사용했다.

 `core.setOutput('key', 'value')` 함수를 호출하면, 액션 워크플로우 내에서 `steps.<STEP ID>.outputs.<OUTPUT KEY>` 형태로 사용할 수 있다.

<br/>

포스트 데이터를 가져와 가공하는 자바스크립트 코드는 make post list 스텝에서 실행된다.

```yaml
      - name: make post list
        id: posts
        run: node .github/make-post-list.js
```

포스트 데이터 가공이 끝나면, `setOutput` 을 호출해 데이터를 내보낸다.

```jsx
// make-post-list.js
const core = require("@actions/core");

// 데이터 가공하는 부분 생략 ...

core.setOutput("posts", JSON.stringify(JSON.stringify(posts)));
```

그러면 다음 스텝부터는 이 데이터에 아래 코드의 마지막 줄의 posts 부분과 같이 `${{ steps.<step_id>.outputs.<output_key> }}` 값으로 접근할 수 있다.

```yaml
      - run: |-
          curl -L \
            -X POST \
            -H 'Accept: application/vnd.github+json' \
            -H "Authorization: Bearer ${{ secrets.DISPATCH_TARGET_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/ooooorobo/ooooorobo/dispatches \
            -d '{"event_type": "recent_post", "client_payload": { "posts": ${{ steps.posts.outputs.posts }} } }'
```

## git으로 받아온 파일의 생성시점 가져오기

문제는, **`git clone` 을 통해 가져온 파일에는 정확한 생성, 수정 시점이 기록되지 않는다**는 것이다. 즉, 파일에는 파일이 실제로 생성됐던 시점이 아니라 `git clone` 을 받은 시점이 기록되어 있다.

![Untitled](/image/66/birthtime-1.png)

`action/checkout`을 통해 레포지토리를 클론받은 후 각 파일의 birthtime을 출력해본 결과, 액션을 실행한 시점인 2023년 4월 26일에 생성된 것으로 되어 있다. 그런데 `package.json` 파일의 실제 생성일은 2022년 1월 19일이다.

<br/>

이 birthdate를 보정해주기 위해, git log에 저장된 정보를 사용한다. 먼저, 쉘 스크립트 코드는 아래와 같다.

```bash
git ls-tree -r --name-only main ./src/pages/posts | while read filename; do
  unixtime=$(git log --follow --format=%at ${filename} | tail -1)
  touchtime=$(date -r ${unixtime} +'%Y%m%d%H%M.%S')
  touch -t ${touchtime} "${filename}"
done
```

타임스탬프는 블로그 포스트만 변경해주면 되기 때문에, `git ls-tree` 커맨드를 사용해 포스트 경로에 있는 파일의 이름을 모두 가져오도록 했다. 그리고 각 파일마다 아래 과정을 거쳐 파일에 타임스탬프를 설정해준다.

<br/>

우선, 어떤 파일의 생성 시점이 언제인가를 알기 위해 `git log` 커맨드를 사용한다.

```bash
git log --follow --format=%at ${filename}
```

- `--follow`: 특정 파일의 기록을 모두 추적한다. 예를 들어, 파일의 이름이 변경됐을 경우 파일의 이름이 변경되기 이전 기록도 가져온다.
    - 참고: [Use —follow option in git log to view a file’s history](https://kgrz.io/use-git-log-follow-for-file-history.html)
- `--format=%at` : 로그 출력 시, author date 값만 가져온다. UNIX 타임스탬프를 사용한다.

그러면 아래와 같은 타임스탬프가 출력된다.

```bash
1682443716
1682443581
1682443415
1682443033
1661444014
1638254829
1637654274
1637654159
1629966134
1629966075
1629962563
(END)
```

가장 첫번째 로그가 파일의 생성 시점이기 때문에, `tail -1` 커맨드로 첫번째 로그의 타임스탬프를 가져온다. 이 값을 `unixtime` 변수에 저장했다.

<br/>

`touch` 명령어의 `-t` 옵션을 사용해서 특정 파일의 타임스탬프를 변경할 수 있다. 이때 타임스탬프는 `[[CC]YY]MMDDhhmm[.SS]` 형식을 사용해야 한다.

위의 UNIX 형식의 타임스탬프를 원하는 형식으로 변경하려면 date 커맨드를 사용하면 된다.

```bash
date -r ${unixtime} +'%Y%m%d%H%M.%S'
```

이 값을 touchtime 변수에 저장하고, `touch -t ${touchtime} "${filename}"` 커맨드로 파일의 타임스탬프를 변경해주면 된다.

![Untitled](/image/66/correct-birthtime.png)

이 과정을 거친 후 파일의 타임스탬프를 찍으면 파일이 처음 커밋된 시간으로 타임스탬프가 찍힌다!

<br/>

이제 정말 최신 순으로 정렬된 포스팅 리스트를 가져올 수 있다. 액션의 마지막 단계에서 이 데이터를 curl 커맨드로 프로필 레포지토리에 전송해주게 했다.

```bash
      - run: |-
          curl -L \
            -X POST \
            -H 'Accept: application/vnd.github+json' \
            -H "Authorization: Bearer ${{ secrets.DISPATCH_TARGET_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/ooooorobo/ooooorobo/dispatches \
            -d '{"event_type": "recent_post", "client_payload": { "posts": ${{ steps.posts.outputs.posts }} } }'
```

### Action secrets

토큰은 yml 파일에 직접 작성하면 안되고, 레포지토리 Security 옵션에서 시크릿 값으로 설정해 줘야 한다. 아래 스크린샷처럼 레포지토리 설정에 들어가 시크릿 값을 추가해 줄 수 있다. 이렇게 추가한 시크릿 값은 위와 같이 `${{ secrets.KEY }}` 형태로 접근할 수 있다.

![Untitled](/image/66/secret-1.png)

시크릿 값은 액션 로그에서도 숨김 처리된다.

![Untitled](/image/66/secret-2.png)

### Workflow permissions

간혹 토큰에 올바른 권한을 줬는데도 아래와 같은 오류가 발생하는 경우가 있다.

```json
{
  "message": "Resource not accessible by personal access token",
  "documentation_url": "https://docs.github.com/rest/reference/repos#create-a-repository-dispatch-event"
}
```

이럴 경우, 레포지토리 설정 > Actions > General > Workflow permissions 에서 권한이 Read and write permissions로 설정해줘야 한다.

# 프로필 레포지토리

프로필 레포지토리의 README.md 파일의 정적인 부분을 정의하기 위해, TEMPLATE.md 파일을 아래와 같이 추가했다.

```markdown
## 📮 New Posts!

<!-- posts here -->
```

workflow_dispatch 이벤트를 받으면 이 템플릿을 열어서 `<!-- posts here-->` 부분을 포스트 목록으로 교체해주면 된다. 자세한 액션 코드는 [여기](https://github.com/ooooorobo/ooooorobo/blob/master/.github/workflows/make-recent-posts.yml)에서 볼 수 있다.

<br/>

그렇게 만들어진게 지금의 프로필!

![Untitled](/image/66/profile3.png)

이것만으론 아직 부족해 보이기도 하지만, 앞으로도 재밌는 방법으로 더 많은 내용을 채워볼 수 있을 것 같다!

export const meta = PostUtil.createPostMeta({
    index: 66,
    title: "내 블로그의 최신 글을 깃허브 프로필에 자동으로 등록하기",
    description: "Github Actions를 활용해, 내 블로그에 올라온 최신 글 목록을 자동으로 깃허브 프로필에 올려보자",
    category: '',
    series: "",
    tags: ["Github Actions"],
    postedAt: '2023.05.06.',
});
export default ({children}) => <PostLayout meta={meta}>{children}</PostLayout>;
